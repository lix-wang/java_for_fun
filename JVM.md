## JVM Notes
* [1.关于JVM](#1)
* [2.JVM运行时数据区](#2)
* [3.对象](#3)
* [4.OutOfMemoryError](#4)
* [5.垃圾回收](#4)
* [6.类文件结构](#6)
* [7.JVM Classloading Mechanism](#7)
* [7.1 Loading](#7.1)
* [7.2 Verification](#7.2)
* [7.3 Preparation](#7.3)
* [7.4 Resolution](#7.4)
* [7.5 Initialization](#7.5)
* [7.6 ClassLoader](#7.6)

<h2 id = "1">1.关于JVM</h2>
&emsp;&emsp; Java程序设计语言、Java虚拟机、Java API类库统称为JDK，JDK是支持Java程序开发的最小环境。Java API中的Java SE API子集和Java虚拟机称为JRE。
Java SE：支持面向桌面级运用的Java平台，提供了完整的Java核心API。Java EE: 支持使用多层架构的企业运用的Java平台。

<h2 id = "2">2.JVM运行时数据区</h2>
&emsp;&emsp; JVM 运行时数据区划分为：方法区、虚拟机栈、本地方法栈、堆、程序计数器。其中方法区和堆由所有线程共享，虚拟机栈、本地方法栈、程序计数器线程隔离。

<br>

### 程序计数器
&emsp;&emsp; 程序计数器是一块较小的内存空间，程序计数器可看作当前线程执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条要执行的字节码指令。

<br>
Jvm多线程是通过线程轮流切换分配处理器时间实现的，所以每条线程都需要有一个程序计数器，各线程计数器之间互不影响，因此这类内存区域为线程私有的内存。
如果执行的是java方法，那么计数器记录的是正在执行的虚拟机字节码指令的地址。如果执行的是Native方法，那么这个计数器的值为空(undefined)，
这块内存区域是Jvm唯一没有规定任何OutOfMemoryError的区域。因为线程的pc register足够存放一个java方法字节码指令地址或者native指针，
因此不会发生OOME。

<br>

### Java虚拟机栈
&emsp;&emsp; Java虚拟机栈也是线程私有的，生命周期与线程相同。虚拟机栈描述的是java方法执行的内存模型：每个方法执行的同时会创建一个栈帧(Stack Frame)，
用以存储局部变量表、操作数栈、动态链接、方法出口等。一个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

<br>
&emsp;&emsp; 局部变量表存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型(指向字节码指令的地址)。
局部变量表最小的容量为变量槽(slot)，一个slot可以存放一个32位以内的数据类型，64位的long和double会占用2个局部变量空间。其余数据类型只占用一个slot。
局部变量表所需的空间会在编译期间完成分配。进入一个方法时，方法需要在帧中分配多大的局部变量空间时完全确定的，在方法运行期间不会改变局部变量表的大小。

<br>
&emsp;&emsp; 这个区域有两种异常：如果线程请求的栈深度大于虚拟机栈的深度，那么将抛出StackOverflowError。
如果虚拟机栈可以动态扩展，扩展时没有申请到足够的内存，那么就会抛出OutOfMemoryError。

<br>

### 本地方法栈
&emsp;&emsp; 虚拟机栈为虚拟机执行Java方法，本地方法栈为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中方法使用的语言、使用方式与
数据结构没有强制规定，因此具体的虚拟机可以自由实现它。有的虚拟机(如HotSpot)直接把本地方法栈和虚拟机栈合二为一。
本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。

<br>

### Java堆
&emsp;&emsp; Java堆是虚拟机管理的内存中最大的一块。Java堆是被所有线程共享的内存区域，虚拟机启动时创建。此内存区域目的是存放对象实例。
几乎所有的对象实例都在这里分配内存。所有对象实例及数组都在这里分配内存，但随着JIT编译器的发展与逃逸分析技术逐渐成熟，
栈上分配、标量替换优化技术会导致所有对象在堆上分配不那么绝对。

<br>
&emsp;&emsp; java堆是垃圾收集器管理的主要区域。现有收集器基本采用分代收集算法，因此Java堆可以细分为：新生代、老年代。
再细致一点可以分为：Eden区、From Survivor空间、To Survivor空间。从内存分配的角度看，线程共享的java堆中可能划分出多个线程私有的分配缓冲区。
Java堆可以处于物理上不连续的内存空间中，只要逻辑上连续即可。实现时既可实现成固定大小的，也可以是可扩展的。当前主流的虚拟机都是按照可扩展来实现的，
通过(-Xmx和-Xms控制)，如果堆中没有内存完成实例分配，并且堆无法再扩展时，将会抛OutOfMemoryError异常。

<br>

### 方法区
&emsp;&emsp; 方法区与Java堆一样是各个线程共享的内存区域。方法区中存放：静态变量、常量、类信息(构造方法/接口定义)、运行时常量池。

<br>
&emsp;&emsp; 在java7之前，方法区用于存储被已虚拟机加载的类信息、常量、静态变量、编译后的代码等数据。
Java虚拟机把方法区描述为堆的一个逻辑部分，但方法区有一个别名叫Non-Heap(非堆)，目的是与Java堆区分开来。
很多人更愿意把方法区称为永久代，本质上两者并不等价，方法区在物理上属于Java堆区中的一部分，永久代是方法区的实现。
这样HotSpot垃圾收集器能像管理Java堆一样管理这部分内存，能省去专门为方法区编写内存管理的代码。

<br>
&emsp;&emsp; 在java8之后，hotspot移除了使用永久代来实现方法区，用元空间(Metaspace)代替。运行时常量池(包含字符串常量池)之前在方法区中，
后来字符串常量池在Java堆中，运行时常量池在元空间中。JVM对方法区的限制很宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可拓展以外，
还可以选择不实现垃圾收集。垃圾收集在方法区比较少出现，但并不意味进了方法区就永久存在，这个区域的内存回收目标主要针对常量池的回收和对类型的卸载。
当方法区无法满足内存分配需求时会抛出OutOfMemoryError异常。

<br>
&emsp;&emsp; java6中，除了JIT(Just-in-time)编译生成的代码存在native memory，其他都在永久代。java7中，字符串常量、静态变量转移到Java堆中，
符号引用转移到Native Memory。java8后，移除永久代使用元空间，永久代是堆的一部分，但元空间属于本地内存。java8后，使用MetaspaceSize、
MaxMetaspaceSize代替PermSize、MaxPermSize。

<br>

### 运行时常量池
&emsp;&emsp; 运行时常量池，是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池。
用以存放**编译期**生成的各种字面量和符号引用，Class文件静态常量池在类加载后进入方法区的运行时常量池中存放。

<br>
&emsp;&emsp; Java虚拟机对Class文件每一部分格式都有严格规定，只有都符合规范，才会被虚拟机认可装载执行，但对于运行时常量池，JVM规范没有任何细节要求。
运行时常量池相对于Class文件常量池具备动态性，Java语言不要求常量必须在编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，
运行期间也可以将新的常量放入池中，例如：String类的intern()方法。当常量池无法申请到内存时会抛出OutOfMemoryError异常。

<br>

### 直接内存
&emsp;&emsp; 直接内存，不是java虚拟机运行时数据区的一部分，也不是JVM规范中定义的内存空间，使用Native函数直接分配堆外内存，
然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，避免了在Java堆和Native堆中来回复制数据。
不会受到Java堆大小的限制，但受本机总内存大小及处理器寻址空间的限制，通常服务器管理员会设置-Xmx，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制，
从而导致动态扩展时出现OutOfMemoryError异常。

<h2 id = "3">3.对象</h2>
&emsp;&emsp; 虚拟机遇到new指令时，先检查这个指令参数能否在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否被加载、解析初始化过。
如果没有，要先执行类加载过程。类加载完成后，会先为新生对象分配内存，对象所需的内存大小在类加载完成后就可以确定。

<br>
创建对象是很频繁的事情，在并发情况下并不是线程安全的，通常有两种解决方式，一种是使用CAS加重试保证分配内存的原子性，另一是每个线程在Java堆中预先分配一小块内存，
称为本地线程分配缓冲(TLAB)，哪个线程要分配内存就在哪个线程的TLAB分配，只有TLAB用完分配新的TLAB时，才需要同步锁定，虚拟机是否使用TLAB，
通过-XX:+/-UseTLAB 参数设定。

<br>
&emsp;&emsp; 内存分配后，虚拟机会将分配到的内存空间初始化为字段数据类型对应的零值，如果使用TLAB，这一过程可以提前在TLAB分配时进行。
这样可以保证对象实例字段在java代码中不赋初值就可以直接使用。接下来会将对象哈希码、对象GC分代年龄等信息放在对象头中。至此从虚拟机角度看，
一个新的对象就产生了。但从Java程序来看，对象创建才刚开始，&lt;init&gt;方法还没执行。执行new后，会执行&lt;init&gt;方法把对象进行初始化，
这样一个对象才算完全产生出来。

<br>

### 对象内存
&emsp;&emsp; 对象在内存中存储的布局可以分为3块区域：对象头、实例数据、对齐填充。

<br>
&emsp;&emsp; 对象头包括两部分信息，第一部分用于存储对象自身的运行时数据。如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。
这部分数据在32位64位虚拟机中，分别为32bit和64bit。对象头另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机用这个指针确定这个对象是哪个类的实例。
如果对象是数组，在对象头中还必须有一块记录数组长度的数据，因为普通对象元数据可以确定对象大小，但数组元数据无法确定数组大小。

<br>
&emsp;&emsp; 实例数据存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响，hotspot默认分配策略为longs/doubles、ints、
shorts/chars、bytes/booleans、oops(Ordinary Object Pointers)，可以看出，相同宽带的字段总是被分配到一起。父类中定义的变量会出现在子类之前。
如果CompactFields参数值为true，子类较窄变量会插入到父类变量空隙中。

<br>
&emsp;&emsp; 对齐填充不是必然存在的，没有什么意义，仅仅起占位符的作用。由于hotspot自动内存管理系统要求对象起始地址必须是8字节的整数倍，
也就是对象大小必须是8字节整数倍，对象头是8字节1倍或2倍，因此当实例数据部分没有对齐时，需要通过对齐填充来补全。

<br>

### 对象的访问
&emsp;&emsp; Java程序需要通过栈上的Reference数据操作堆上的具体对象，目前主流的对象访问方式有使用句柄和直接指针两种。
使用句柄访问的话，需要在Java堆中划分出一块内存作为句柄池，reference存的是对象句柄的地址，句柄中会有两个指针，分别指向对象的实例数据和对象类型数据，
对象实例数据放在Java堆中，对象类型数据放在方法区中。如果使用直接指针访问，reference指向java对象，java堆对象中就必须包含一个指向对象类型数据的指针。

<br>
&emsp;&emsp; 使用句柄最大好处在于Reference存储的是稳定的句柄的地址，在对象被移动时只会改变句柄中实例数据指针，而Reference不需要修改。
使用直接指针，好处是速度更快，节省了一次指针定位的时间开销，对象访问在Java中很频繁，这类开销积少成多节省的执行成本也是很可观的。
hotspot是直接访问对象的。

<h2 id = "4">4.OutOfMemoryError</h2>
&emsp;&emsp; 除了程序计数器，都是可能发生OutOfMemoryError的。

<br>

### Java堆溢出
&emsp;&emsp; 如果不断创建对象，并且保证GC Roots到对象之间有可达路径避免垃圾回收机制清除对象，那么在对象数量达到最大堆容量后，会产生内存溢出异常。
通过参数-XX:+HeapDumpOnOutOfMemoryError 可以让虚拟机在出现内存溢出异常时Dump出当前内存堆转储快照以便事后进行分析。

<br>

### 虚拟机栈和本地方法栈溢出
&emsp;&emsp; 在hotspot虚拟机中，不区分虚拟机栈和本地方法栈，因此对于hotspot虽然-Xoss参数(设置本地方法栈大小)存在，但实际是无效的。
栈容量只由-Xss参数设置。一般都抛出StackOverFlowError异常。在单线程下，无论由于栈帧太大，还是虚拟机栈容量太小，当内存无法分配时，
都抛出StackOverflowError异常。

<br>
&emsp;&emsp; 虚拟机栈和本地方法栈的内存 = 虚拟机内存 - java堆 - 方法区 - 程序计数器。每个线程分配的栈容量越大，可以建立的线程数就越少，
建立线程时就越容易把剩下的内存耗尽。如果时建立太多线程导致的内存溢出，那么可以通过减少最大堆和减少栈容量，来换取更多的线程。

<br>

### 方法区和运行时常量池溢出
&emsp;&emsp; 可以通过-XX:PermSize和-XX:MaxPermSize限制方法区的大小。间接限制常量池的容量。方法区溢出是一种常见的内存溢出异常，
一个类要被垃圾收集器回收掉，判断条件是很苛刻的。经常动态生成大量Class的应用容易产生OOM。String.intern()是一个native方法：
如果字符串常量池已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象，否则，将此String对象包含的字符串添加到常量池中，
并返回代表池中这个字符串的String对象。

<br>

### 本机直接内存溢出
&emsp;&emsp; 直接内存可以通过-XX:MaxDirectMemorySize指定，不指定默认与Java堆最大值一样。DirectByteBuffer分配内存抛内存溢出异常时，
并没有真正申请分配内存，而是先计算无法分配，于是手动抛出了异常，真正分配内存的方法是unsafe.allocateMemory()。由于直接内存导致的内存溢出，
特征是Heap Dump文件不会有明显的异常，OOM之后Dump文件很小，而且程序直接或间接使用了NIO，那么可能就是这方面原因。

<h2 id = "5">5.垃圾回收</h2>
&emsp;&emsp; 程序计数器、虚拟机栈、本地方法栈，生命周期同线程生命周期，这些区域的内存分配和回收具备确定性。Java堆和方法区不一样，
一个接口的多个实现类需要的内存不一样，一个方法中多个分支需要的内存也不一样，只有程序运行期才知道会创建哪些对象，这部分内存回收是动态的。
这部分也是垃圾收集器所关注的部分。

<br>

### 对象存活状态判断
#### 1.引用计数算法
&emsp;&emsp; 给对象添加一个引用计数器，有地方引用时计数器加一，引用失效，计数器减一，计数器为0的对象不可能再被使用。这种方法实现简单，判断效率高，
但是无法解决对象相互引用的问题。比如对象A、B互相引用，但这两个对象已无法被访问，但相互引用导致GC无法对它们进行回收。

<br>

#### 2.可达性分析算法
&emsp;&emsp; 将GC Roots作为起始点，从节点向下搜索，搜索走过的路称为引用链，当一个对象到GC Roots没有任何引用链相连，则证明对象是不可用的。
可作为GC Roots的对象包含：虚拟机栈(栈帧中的局部变量表)中引用的对象；方法区中类静态属性引用的对象；方法区中常量引用的对象；
本地方法栈中JNI(Native方法)引用的对象。

<br>
&emsp;&emsp; 引用计数法和可达性分析算法，都是引用有关。Java中引用定义：如果reference类型数据中存储的数值代表另一块内存的起始地址，
就称为这块内存代表着一个引用。这种定义使得对象只有被引用或没有被引用两种状态。所以对引用进行了扩充，根据引用强度将引用分为：强引用、软引用、弱引用、虚引用。

<br>
&emsp;&emsp; 强引用类似Object obj = new Object()，这类引用只要强引用存在，垃圾收集器就永远不会被回收掉。软引用描述有用但非必须对象，对于软引用关联的对象，
在系统将要发生内存溢出异常之前，会将这些对象列入回收范围中进行二次回收，如果回收还没有足够内存，那么将抛出内存溢出异常，使用SoftReference实现。
弱引用描述非必需对象，被弱引用关联的对象，只能生存到下一次垃圾收集发生之前。GC工作时，无论内存是否足够，都会回收掉只被弱引用关联的对象。
使用WeakReference实现。虚引用是最弱的引用关系，一个对象是否有虚引用不会对其生存时间构成影响，也无法通过虚引用获得一个对象实例。
为一个对象设置虚引用关联的唯一目的是能在这个对象被收集器回收时收到一个系统通知。使用PhantomReference实现。

<br>
&emsp;&emsp; 软引用可以实现内存敏感的高速缓存，软引用可以和一个引用队列(ReferenceQueue)联合使用，如果软引用所引用的对象被垃圾回收，
Java虚拟机就会把这个软引用加入到与之关联的引用队列中。弱引用类似软引用，只是生命周期更短，可以与引用队列一起使用。虚引用必须和引用队列一起使用，
GC回收对象时，发现该对象还有虚引用，那么会在回收之前把虚引用加入到与之关联的引用队列。程序可以通过引用队列是否加入了虚引用，了解被引用的对象是否要被回收，
就可以在引用对象内存被回收前采取必要的行动。

<br>

### 对象回收过程
&emsp;&emsp; 对于不可达对象，在消亡前至少要经历两次标记过程。如果对象与GC Roots没有引用关系，那么会第一次标记并筛选，筛选该对象是否有必要执行finalize方法，
如果对象没覆盖finalize()方法，或者finalize()已被调用过，那么视为没必要执行。如果有必要执行finalize()方法，那么对象会放置在F-Queue队列中，
并稍后由虚拟机自动建立的、低优先级的Finalizer线程执行。虚拟机会触发finalize()方法，但并不等待运行结束，因为如果等待，且finalize执行缓慢或循环，
那么其他对象将永久等待，导致内存回收系统崩溃。finalize后GC对F-Queue中对象进行二次标记，在finalize中如果重新构建了引用链，那么在第二次标记时，
将被移除出即将回收集合。如果对象这时还没逃脱，那么将被回收。具有不确定性，不保证对象调用顺序，不建议使用finalize()方法。

<br>

### 方法区回收
&emsp;&emsp; 方法区主要回收废弃常量和无用类，如果常量池中一个常量没有地方进行引用，这时发生内存回收，必要的话就会被清理出常量池。
判断一个类是否为无用类，必须满足3个条件：1.该类所有实例被回收，Java堆中不存在该类的任何实例。2.加载该类的ClassLoader被回收。
3.该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问。通过-Xnoclassgc控制是否对类进行回收，可以使用-verbose:class以及
-XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类加载卸载信息。在频繁使用反射、动态代理、CGLib等这类频繁自定义ClassLoader的
场景都需要虚拟机具备类卸载的功能，以避免内存溢出。

<br>

### 垃圾收集算法
#### 标记-清除算法
&emsp;&emsp; 该算法分两阶段：首先标记出所有要回收的对象，标记完成后统一回收所有被标记的对象。不足在于：1.效率不高，标记和清除两个过程效率都不高。
2.标记清除后会产生大量不连续的内存碎片，碎片太多会导致分配较大对象时，无法找到足够的连续内存而不得不再触发一次垃圾收集动作。

<br>

#### 复制算法
&emsp;&emsp; 将内存按容量划分为大小相等的两块，每次使用其中一块。一块使用完毕，将还存活的复制到另一块，再把用过的那块内存空间一次清理掉。
实现简单，运行高效，只是牺牲了一半的内存空间。研究表明新生代中98%对象都是朝生夕死，因此将内存划分为一块较大的Eden空间和两块较小的Survivor空间，
Eden : Survivor = 8 : 1。每次使用Eden和其中一块Survivor，因此每次新生代中可用内存空间为整个新生代容量的90%。当Survivor不够用时，
需要依赖老年代进行分配担保。如果Survivor没有足够空间存放上一次新生代收集下来的存活对象，这些对象将直接通过分配担保机制进入老年代。

<br>

#### 标记-整理算法
&emsp;&emsp; 存活率高时，复制算法要进行较多复制操作，效率变低。标记-整理法与标记-清除法类似，只是不是直接清理可回收对象，而是让所有存活对象往一端移动，
然后清理掉端边界以外的内存。

<br>

#### 分代收集算法
&emsp;&emsp; 当前商业虚拟机采用分代收集算法，根据对象存活周期的不同，将内存分为几块。一般分为新生代和老年代。新生代每次收集有大量对象消亡，
少量存活，就选用复制算法，老年代存活率高，没有额外空间进行分配担保，需要采用标记-清理或标记-整理进行回收。

<br>

### Hotspot 枚举根节点
&emsp;&emsp; 可达性分析从GC Roots节点开始找引用链，很多应用仅方法区就几百兆，逐个检查引用会消耗很多时间。GC时需要停顿所有Java执行线程(Stop The World)。
虚拟机通过OopMap数据结构直接知道哪些地方存放着对象引用。在类加载完成的时候，Hotspot就把对象内什么偏移量上是什么类型数据计算出来。
在OopMap协助下，Hotspot可以快速准确完成GC Roots枚举。

<br>

### 安全点
&emsp;&emsp; Hotspot不会为每条指令都生成OopMap，只在安全点产生。程序只要在到达安全点时才暂停。Safepoint不能太少，以至于GC等待时间太长，
也不能过于频繁。有两种方案可以在GC时让所有线程(除执行JNI调用的线程)都跑到最近的安全点停顿：抢先式中断和主动式中断。抢先式中断是GC时先中断所有线程，
如果发现中断的地方不在安全点，就恢复线程，让它跑到安全点。主动式中断是当GC需要中断线程时，设置一个标志，各个线程轮询标志，发现中断标志为真时自己中断挂起。
轮询标志的地方和安全点是重合的。

<br>
&emsp;&emsp; JVM会在内存分配的地方(即new一个新对象的时候)和长时间执行区块结束的时刻放置安全点，安全点一般会在如下几个位置点：
1、循环的末尾(无界循环)；2.方法临返回前；3.调用方法后；4.抛异常的位置。对于for (int i = 0; i < xxx; i++) 这种可以设置计数器的有限次数循环，
叫有界循环。对于for(;;) if condition return; 这种不知道要循环多少次，通过条件完成循环的叫无界循环，也可以用while实现无界循环。

<br>

### 安全区域
&emsp;&emsp; 当线程不执行即没有分配cpu时间时，如sleep或blocked时，无法相应JVM中断请求到达安全点，这时候需要安全区域(Safe Region)解决。
安全区域指在一段代码片段中，引用关系不会发生变化，在这个区域任意地方开始GC都是安全的。线程到达Safe Region时标记自己，当这段时间要发起GC时，
不用管标记为Safe Region状态的线程，线程离开Safe Region时，要检查是否完成了根节点枚举或整个GC过程，如果完成继续执行，
否则必须等待收到可以离开Safe Region的信号为止。在线程睡眠阻塞时，我们可以认为线程已经到达了safe region。在执行native方法时，
由于执行的是JVM管理外的代码，不会修改JVM状态，因此此时可看作已进入safe point 或 safe region。

<br>

### 垃圾收集器
#### Serial收集器
&emsp;&emsp; Serial收集器是单线程收集器，是单线程收集器，进行垃圾收集时必须暂停所有其他所有工作线程，直到收集结束。Serial收集器对于运行在
Client模式下的虚拟机是一个很好的选择。相比其他单线程收集器，简单高效。

<br>

#### ParNew收集器
&emsp;&emsp; 是Serial的多线程版本，Serial是许多运行在Server模式下的虚拟机首选的新生代收集器，使用复制算法。
只有Serial和ParNew能和CMS一起使用。CMS是老年代收集器。

<br>

#### Parallel Scavenge收集器
&emsp;&emsp; Parallel Scavenge是一个新生代收集器，使用复制算法。也是并行的多线程收集器。Parallel Scavenge收集器目的是达到一个可控的吞吐量，
吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)。Parallel Scavenge可以使用自适应调节策略。

<br>

#### Serial Old收集器
&emsp;&emsp; Serial Old是Serial收集器的老年代版本，使用标记-整理算法。主要两种用户：JDK1.5前与Parallel Scavenge收集器搭配使用；
作为CMS后备预案，在并发收集器发生Concurrent Mode Failure时使用。

<br>

#### Parallel Old收集器
&emsp;&emsp; Parallel Old是Parallel Scavenge收集器的老年代版本。使用标记-整理算法。

<br>

#### CMS收集器
&emsp;&emsp; CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。CMS使用标记-清除算法，整个过程分四步：
1.初始标记。2.并发标记。3.重新标记。4.并发清除。初始标记、重新标记需要Stop The World。初始标记只是标记GC Roots能直接关联到的对象，速度很快。
并发标记进行GC Roots Tracing。重新标记为了修正并发标记期间因用户程序继续运作导致标记产生变动的那一部分对象的标记记录，
这个阶段停顿时间比初始标记阶段长，但比并发标记时间短。并发标记和并发清除能与用户线程一起并发执行。

<br>
&emsp;&emsp; CMS优点在于：并发收集、低停顿，缺点在于：CMS对CPU资源敏感，CMS默认回收线程数为: (CPU数 + 3) / 4。在CPU数在4个以上时，
垃圾收集线程不少于25%的CPU资源，在CPU不足4个时，占用CPU资源占比更多。因此虚拟机提供了被称为"增量式并发收集器"的CMS收集器变种，
在并发标记、清理时，让GC线程、用户线程交替执行，这样垃圾收集时间会更长，但对用户程序影响会小一些。增量式CMS效果一般，已经deprecated。

<br>
&emsp;&emsp; 由于CMS并发标记、清理是与用户线程并发执行的，因此在标记后还会产生垃圾，这部分垃圾叫"浮动垃圾"，因此CMS需要给并发的用户线程预留内存，
CMS不能等到老年代几乎被填满再进行GC，使用-XX:CMSInitiatingOccupancyFraction来确定触发GC时的使用率，如果CMS运行时内存不足，
会出现Concurrent Mode Failure失败，这时使用后备预案，临时使用Serial Old来进行老年代的GC，只是这样停顿时间会变长。

<br>
&emsp;&emsp; CMS基于标记-清除，因此会产生空间碎片，空间碎片过多时会出现老年代有大量剩余空间，但是无法找到足够的内存分配当前对象。这样会触发一次Full GC。
CMS提供了-XX:CMSCompactAtFullCollection 默认开启，用于在CMS进行Full GC时开启内存碎片的合并整理过程。但内存整理无法并发，导致停顿时间变长。
虚拟机提供了-XX:CMSFullGCsBeforeCompaction，设置执行多少次不压缩的Full GC后，进行一次带压缩的Full GC。

<br>

#### G1收集器
&emsp;&emsp; G1(Garbage-First)特点：并行与并发；分代收集；空间整理；可预测的停顿。G1从整体看是基于标记-整理算法，从局部(两个Region)看，
基于复制算法，G1运行期间不会产生内存碎片。G1能建立可预测的停顿空间模型，能让使用者明确在长度为M毫秒的时间段内，消耗在GC上不超过N毫秒。
G1将Java堆划分为多个大小相等的独立区域(Region)。G1会优先收集价值最大的Region，这样保证在有限的时间内尽可能提高收集效率。G1收集过程分四步：
1.初始标记。2.并发标记。3.最终标记。4.筛选回收。

<br>

### 对象内存分配
&emsp;&emsp; 对象主要分配在新生代Eden区，如果启动了本地线程分配缓冲，那么优先分配在TLAB上。对象优先分配在新生代Eden区，Eden没有足够空间，
那么执行一次Minor GC。-XX:+PrintGCDetails在收集器发生GC时打印回收日志，并在进程退出时输出当前内存区域分配情况。

<br>
&emsp;&emsp; Minor GC 新生代GC，发生在新生代的垃圾收集，Minor GC发生很频繁，回收速度也很快。 Major GC/Full GC 老年代GC，发生在老年代的GC，
Major GC至少伴随一次Minor GC，Major GC速度比Minor GC慢10倍以上。

<br>

### 大对象直接进入老年代
&emsp;&emsp; 典型的大对象是很长的字符串以及数组。虚拟机提供了-XX:PretenureSizeThreshold，大于这个值的对象直接在老年代分配。
这样避免在Eden以及两个Survivor之间发生大量内存复制。

<br>

### 长期存活的对象进入老年代
&emsp;&emsp; 虚拟机给每个对象定义了对象年龄计数器。如果对象在Eden出生，经过一次Minor GC后仍存活，并且能被Survivor容纳，那么被移动到Survivor中，
年龄加1，当年龄增加到一定程度(默认为15)，会升到老年代。对于晋升老年代的年龄阀值可以通过-XX:MaxTenuringThreshold设置。

<br>

### 动态对象年龄判定
&emsp;&emsp; 如果Survivor空间中相同年龄对象大小总和占Survivor空间的一般，年龄大于或等于这个年龄的对象可以进入老年代。

<br>

### 空间分配担保
&emsp;&emsp; Minor GC前会检查老年代最大可用连续空间是否大于新生代所有对象总空间，如果成立，那么Minor GC确保是安全的。不成立的话，
虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许的话，那么会检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小，
如果大于会尝试进行一次Minor GC，如果小于或者HandlePromotionFailure不允许冒险，那么要改为进行一次Full GC。如果某次Minor GC存活后的对象突增，
高于平均值，那么会导致担保失败，如果出现HandlePromotionFailure失败，那么只好失败后重新发起一次Full GC。

<h2 id = "6">6.类文件结构</h2>
&emsp;&emsp; 任何一个Class文件都对应着唯一一个类或者接口的定义信息，Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序，
紧凑排列在Class文件中，中间没有添加任何分隔符，当遇到占用8位字节以上空间的数据项时，会按照高位在前的方式分割成若干个8位字节进行存储。
Class文件格式采用一种类似C语言结构体的伪结构存储数据，这种伪结构只有两种数据类型：无符号数和表。

<br>

### Class文件版本
&emsp;&emsp; Class文件头4个字节称为魔数(Magic Number)，用来确定这个文件是否为一个能被虚拟机接受的Class文件。第5和第6个字节是次版本号(Minor Version)，
第7第8个字节是主版本号(Major Version)。Class版本号能用来判断当前版本的虚拟机能否执行这个Class文件。

<br>

### 常量池
&emsp;&emsp; 紧接着主次版本号后是常量池入口。常量池是Class文件结构中与其他项目关联最多的数据类型，也是Class文件中第一个出现的表类型数据项目。
常量池中常量数量不固定，在常量池入口需要放置一项2字节的数据，用来代表常量池容量计数值，常量池计数是从1开始的。常量池中主要存放两大类常量：
字面量和符号引用。字面量接近Java语言层面的常量概念，如文本字符串、声明为final的常量值等，符号引用包含下面三类常量：类和接口的全限定名；
字段的名称和描述符；方法的名称和描述符。虚拟机在加载Class文件时进行动态连接，也就是说Class文件不会保存各个方法、字段的最终内存布局信息。

<br>
&emsp;&emsp; 常量池中每一项常量都是一个表。每个表第一位是一个u1(一字节无符号数)类型的标志位(tag)。

<br>

### 访问标志
&emsp;&emsp; 

<h2 id = "7">7.JVM Classloading Mechanism</h2>
&emsp;&emsp; 类的整个生命周期包括7个阶段：加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、
初始化(Initialization)、使用(Using)、卸载(Unloading)。其中验证(Verification)、准备(Preparation)、解析(Resolution)，
3个阶段统称为连接(Linking)。
<br>
&emsp;&emsp; 其中加载(Loading)、验证(Verification)、准备(Preparation)、初始化(Initialization)、卸载(Unloading)，
这5个阶段顺序是确定的，因为可能采用动态绑定。遇到new、getstatic、publicstatic、invokestatic，如果类没有初始化，那么要先触发初始化。
场景为：使用new实例化对象、读取或设置一个类的静态字段（被final修饰，在编译期已经把结果放入常量池的静态字段除外）、调用一个类的静态方法、
使用java.lang.reflect包的方法对类进行反射调用的时候、当初始化一个类的时候，其父类还没有初始化、虚拟机启动时，
会先初始化主类（包含main()的类）。这些行为被称作对一个类的主动引用。
<br>
&emsp;&emsp; 接口也会初始化，接口中不能使用静态语句块，但仍会有<clinit>()类构造器，接口在初始化时，并不要求父接口全部都完成了初始化，
只有在真正使用到父接口是，才会初始化。

<h3 id = "7.1">7.1 Loading</h3>
&emsp;&emsp; 加载阶段完成以下3件事：1.通过一个类的全限定名来获取定义该类的二进制字节流。
2.将字节流所代表的静态存储结构转化为方法区的运行时数据结构。3.在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据入口。

<h3 id = "7.2">7.2 Verification</h3>
&emsp;&emsp; 验证是连接阶段的第一步，为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，不会危害虚拟机自身的安全。
会完成以下4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。
<br>
&emsp;&emsp; 文件格式验证是基于二进制字节流进行的，只有通过这个阶段的验证后，字节流才会进入内存的方法区中进行存储。后面的阶段都是基于方法区中的存储结构进行的，
不会再直接操作字节流。
<br>
&emsp;&emsp; 元数据验证，主要对类的元数据信息进行校验，确保不存在不符合Java语言规范的元数据信息。
<br>
&emsp;&emsp; 字节码验证，通过数据流和控制流分析，确保程序语义是合法的、符合逻辑的。将对类的方法体进行校验，保证不会作出危害虚拟机的事件。
<br>
&emsp;&emsp; 符号引用验证，判断引用的类、方法、字段等的引用合法性，发生在虚拟机将符号引用转化为直接引用时，在解析阶段发生。

<h3 id = "7.3">7.3 Preparation</h3>
&emsp;&emsp; 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量使用的内存都在方法区中进行分配。
例如：public static int value = 123; 这个类变量在准备阶段之后，值为0，而不是123。因为这时候尚未开始执行任何Java方法，
真正赋值是在程序被编译后，执行类构造器<clinit>()方法时完成赋值。赋值动作将会在初始化阶段才会执行。
如果是常量，那么在准备阶段会被初始化为指定的值，如：public static final int value = 123; 此时准备阶段，会赋真值。

<h3 id = "7.4">7.4 Resolution</h3>
&emsp;&emsp; 解析阶段是将虚拟机常量池中的符号引用替换为直接引用的过程。符号引用只要能无歧义的定位到目标即可，引用的目标不一定已经加载到内存中。
直接引用可以是指向目标的指针、相对偏移量或一个能间接定位到目标的句柄。如果有了直接引用，那么引用的目标必定已经在内存中存在。

<h3 id = "7.5">7.5 Initialization</h3>
&emsp;&emsp; 初始化是类加载的最后一步，初始化阶段是执行类构造器<clinit>()方法的过程。
<clinit>() 方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，静态语句块中只能访问到定义在静态语句块之前的变量，
定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。<clinit>() 方法与类的构造函数不同，不需要显式的调用父类构造器，
虚拟机会保证在子类<clinit>()方法执行前，父类的<clinit>()方法已经执行完毕。

<h2 id = "7.6">7.6 ClassLoader</h2>
通过一个类的全限定名来获取描述此类的二进制字节流，这个动作被放到JVM外部实现，实现这个动作的代码模块称为类加载器。类加载器采用双亲委派模型，
如果一个类记载器收到了类加载的请求，首先不会自己去尝试加载这个类，而是把这个请求委派给父类来做，父加载器无法加载时，才会尝试自己去加载。
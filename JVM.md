## JVM Notes
* [1.关于JVM](#1)
* [2.JVM运行时数据区](#2)
* [3.对象](#3)
* [4.OutOfMemoryError](#4)
* [5.垃圾回收](#5)
* [6.类文件结构](#6)
* [7.字节码指令](#7)
* [8.虚拟机类加载机制](#8)
* [9.虚拟机字节码执行引擎](#9)

<h2 id = "1">1.关于JVM</h2>
&emsp;&emsp; Java程序设计语言、Java虚拟机、Java API类库统称为JDK，JDK是支持Java程序开发的最小环境。Java API中的Java SE API子集和Java虚拟机称为JRE。
Java SE：支持面向桌面级运用的Java平台，提供了完整的Java核心API。Java EE: 支持使用多层架构的企业运用的Java平台。

<h2 id = "2">2.JVM运行时数据区</h2>
&emsp;&emsp; JVM 运行时数据区划分为：方法区、虚拟机栈、本地方法栈、堆、程序计数器。其中方法区和堆由所有线程共享，虚拟机栈、本地方法栈、程序计数器线程隔离。

<br>

### 程序计数器
&emsp;&emsp; 程序计数器是一块较小的内存空间，程序计数器可看作当前线程执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条要执行的字节码指令。

<br>
Jvm多线程是通过线程轮流切换分配处理器时间实现的，所以每条线程都需要有一个程序计数器，各线程计数器之间互不影响，因此这类内存区域为线程私有的内存。
如果执行的是java方法，那么计数器记录的是正在执行的虚拟机字节码指令的地址。如果执行的是Native方法，那么这个计数器的值为空(undefined)，
这块内存区域是Jvm唯一没有规定任何OutOfMemoryError的区域。因为线程的pc register足够存放一个java方法字节码指令地址或者native指针，
因此不会发生OOME。

<br>

### Java虚拟机栈
&emsp;&emsp; Java虚拟机栈也是线程私有的，生命周期与线程相同。虚拟机栈描述的是java方法执行的内存模型：每个方法执行的同时会创建一个栈帧(Stack Frame)，
用以存储局部变量表、操作数栈、动态链接、方法出口等。一个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

<br>
&emsp;&emsp; 局部变量表存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型(指向字节码指令的地址)。
局部变量表最小的容量为变量槽(slot)，一个slot可以存放一个32位以内的数据类型，64位的long和double会占用2个局部变量空间。其余数据类型只占用一个slot。
局部变量表所需的空间会在编译期间完成分配。进入一个方法时，方法需要在帧中分配多大的局部变量空间时完全确定的，在方法运行期间不会改变局部变量表的大小。

<br>
&emsp;&emsp; 这个区域有两种异常：如果线程请求的栈深度大于虚拟机栈的深度，那么将抛出StackOverflowError。
如果虚拟机栈可以动态扩展，扩展时没有申请到足够的内存，那么就会抛出OutOfMemoryError。

<br>

### 本地方法栈
&emsp;&emsp; 虚拟机栈为虚拟机执行Java方法，本地方法栈为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中方法使用的语言、使用方式与
数据结构没有强制规定，因此具体的虚拟机可以自由实现它。有的虚拟机(如HotSpot)直接把本地方法栈和虚拟机栈合二为一。
本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。

<br>

### Java堆
&emsp;&emsp; Java堆是虚拟机管理的内存中最大的一块。Java堆是被所有线程共享的内存区域，虚拟机启动时创建。此内存区域目的是存放对象实例。
几乎所有的对象实例都在这里分配内存。所有对象实例及数组都在这里分配内存，但随着JIT编译器的发展与逃逸分析技术逐渐成熟，
栈上分配、标量替换优化技术会导致所有对象在堆上分配不那么绝对。

<br>
&emsp;&emsp; java堆是垃圾收集器管理的主要区域。现有收集器基本采用分代收集算法，因此Java堆可以细分为：新生代、老年代。
再细致一点可以分为：Eden区、From Survivor空间、To Survivor空间。从内存分配的角度看，线程共享的java堆中可能划分出多个线程私有的分配缓冲区。
Java堆可以处于物理上不连续的内存空间中，只要逻辑上连续即可。实现时既可实现成固定大小的，也可以是可扩展的。当前主流的虚拟机都是按照可扩展来实现的，
通过(-Xmx和-Xms控制)，如果堆中没有内存完成实例分配，并且堆无法再扩展时，将会抛OutOfMemoryError异常。

<br>

### 方法区
&emsp;&emsp; 方法区与Java堆一样是各个线程共享的内存区域。方法区中存放：静态变量、常量、类信息(构造方法/接口定义)、运行时常量池。

<br>
&emsp;&emsp; 在java7之前，方法区用于存储被已虚拟机加载的类信息、常量、静态变量、编译后的代码等数据。
Java虚拟机把方法区描述为堆的一个逻辑部分，但方法区有一个别名叫Non-Heap(非堆)，目的是与Java堆区分开来。
很多人更愿意把方法区称为永久代，本质上两者并不等价，方法区在物理上属于Java堆区中的一部分，永久代是方法区的实现。
这样HotSpot垃圾收集器能像管理Java堆一样管理这部分内存，能省去专门为方法区编写内存管理的代码。

<br>
&emsp;&emsp; 在java8之后，hotspot移除了使用永久代来实现方法区，用元空间(Metaspace)代替。运行时常量池(包含字符串常量池)之前在方法区中，
后来字符串常量池在Java堆中，运行时常量池在元空间中。JVM对方法区的限制很宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可拓展以外，
还可以选择不实现垃圾收集。垃圾收集在方法区比较少出现，但并不意味进了方法区就永久存在，这个区域的内存回收目标主要针对常量池的回收和对类型的卸载。
当方法区无法满足内存分配需求时会抛出OutOfMemoryError异常。

<br>
&emsp;&emsp; java6中，除了JIT(Just-in-time)编译生成的代码存在native memory，其他都在永久代。java7中，字符串常量、静态变量转移到Java堆中，
符号引用转移到Native Memory。java8后，移除永久代使用元空间，永久代是堆的一部分，但元空间属于本地内存。java8后，使用MetaspaceSize、
MaxMetaspaceSize代替PermSize、MaxPermSize。

<br>

### 运行时常量池
&emsp;&emsp; 运行时常量池，是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池。
用以存放**编译期**生成的各种字面量和符号引用，Class文件静态常量池在类加载后进入方法区的运行时常量池中存放。

<br>
&emsp;&emsp; Java虚拟机对Class文件每一部分格式都有严格规定，只有都符合规范，才会被虚拟机认可装载执行，但对于运行时常量池，JVM规范没有任何细节要求。
运行时常量池相对于Class文件常量池具备动态性，Java语言不要求常量必须在编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，
运行期间也可以将新的常量放入池中，例如：String类的intern()方法。当常量池无法申请到内存时会抛出OutOfMemoryError异常。

<br>

### 直接内存
&emsp;&emsp; 直接内存，不是java虚拟机运行时数据区的一部分，也不是JVM规范中定义的内存空间，使用Native函数直接分配堆外内存，
然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，避免了在Java堆和Native堆中来回复制数据。
不会受到Java堆大小的限制，但受本机总内存大小及处理器寻址空间的限制，通常服务器管理员会设置-Xmx，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制，
从而导致动态扩展时出现OutOfMemoryError异常。

<h2 id = "3">3.对象</h2>
&emsp;&emsp; 虚拟机遇到new指令时，先检查这个指令参数能否在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否被加载、解析初始化过。
如果没有，要先执行类加载过程。类加载完成后，会先为新生对象分配内存，对象所需的内存大小在类加载完成后就可以确定。

<br>
创建对象是很频繁的事情，在并发情况下并不是线程安全的，通常有两种解决方式，一种是使用CAS加重试保证分配内存的原子性，另一是每个线程在Java堆中预先分配一小块内存，
称为本地线程分配缓冲(TLAB)，哪个线程要分配内存就在哪个线程的TLAB分配，只有TLAB用完分配新的TLAB时，才需要同步锁定，虚拟机是否使用TLAB，
通过-XX:+/-UseTLAB 参数设定。

<br>
&emsp;&emsp; 内存分配后，虚拟机会将分配到的内存空间初始化为字段数据类型对应的零值，如果使用TLAB，这一过程可以提前在TLAB分配时进行。
这样可以保证对象实例字段在java代码中不赋初值就可以直接使用。接下来会将对象哈希码、对象GC分代年龄等信息放在对象头中。至此从虚拟机角度看，
一个新的对象就产生了。但从Java程序来看，对象创建才刚开始，&lt;init&gt;方法还没执行。执行new后，会执行&lt;init&gt;方法把对象进行初始化，
这样一个对象才算完全产生出来。

<br>

### 对象内存
&emsp;&emsp; 对象在内存中存储的布局可以分为3块区域：对象头、实例数据、对齐填充。

<br>
&emsp;&emsp; 对象头包括两部分信息，第一部分用于存储对象自身的运行时数据。如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。
这部分数据在32位64位虚拟机中，分别为32bit和64bit。对象头另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机用这个指针确定这个对象是哪个类的实例。
如果对象是数组，在对象头中还必须有一块记录数组长度的数据，因为普通对象元数据可以确定对象大小，但数组元数据无法确定数组大小。

<br>
&emsp;&emsp; 实例数据存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响，hotspot默认分配策略为longs/doubles、ints、
shorts/chars、bytes/booleans、oops(Ordinary Object Pointers)，可以看出，相同宽带的字段总是被分配到一起。父类中定义的变量会出现在子类之前。
如果CompactFields参数值为true，子类较窄变量会插入到父类变量空隙中。

<br>
&emsp;&emsp; 对齐填充不是必然存在的，没有什么意义，仅仅起占位符的作用。由于hotspot自动内存管理系统要求对象起始地址必须是8字节的整数倍，
也就是对象大小必须是8字节整数倍，对象头是8字节1倍或2倍，因此当实例数据部分没有对齐时，需要通过对齐填充来补全。

<br>

### 对象的访问
&emsp;&emsp; Java程序需要通过栈上的Reference数据操作堆上的具体对象，目前主流的对象访问方式有使用句柄和直接指针两种。
使用句柄访问的话，需要在Java堆中划分出一块内存作为句柄池，reference存的是对象句柄的地址，句柄中会有两个指针，分别指向对象的实例数据和对象类型数据，
对象实例数据放在Java堆中，对象类型数据放在方法区中。如果使用直接指针访问，reference指向java对象，java堆对象中就必须包含一个指向对象类型数据的指针。

<br>
&emsp;&emsp; 使用句柄最大好处在于Reference存储的是稳定的句柄的地址，在对象被移动时只会改变句柄中实例数据指针，而Reference不需要修改。
使用直接指针，好处是速度更快，节省了一次指针定位的时间开销，对象访问在Java中很频繁，这类开销积少成多节省的执行成本也是很可观的。
hotspot是直接访问对象的。

<h2 id = "4">4.OutOfMemoryError</h2>
&emsp;&emsp; 除了程序计数器，都是可能发生OutOfMemoryError的。

<br>

### Java堆溢出
&emsp;&emsp; 如果不断创建对象，并且保证GC Roots到对象之间有可达路径避免垃圾回收机制清除对象，那么在对象数量达到最大堆容量后，会产生内存溢出异常。
通过参数-XX:+HeapDumpOnOutOfMemoryError 可以让虚拟机在出现内存溢出异常时Dump出当前内存堆转储快照以便事后进行分析。

<br>

### 虚拟机栈和本地方法栈溢出
&emsp;&emsp; 在hotspot虚拟机中，不区分虚拟机栈和本地方法栈，因此对于hotspot虽然-Xoss参数(设置本地方法栈大小)存在，但实际是无效的。
栈容量只由-Xss参数设置。一般都抛出StackOverFlowError异常。在单线程下，无论由于栈帧太大，还是虚拟机栈容量太小，当内存无法分配时，
都抛出StackOverflowError异常。

<br>
&emsp;&emsp; 虚拟机栈和本地方法栈的内存 = 虚拟机内存 - java堆 - 方法区 - 程序计数器。每个线程分配的栈容量越大，可以建立的线程数就越少，
建立线程时就越容易把剩下的内存耗尽。如果时建立太多线程导致的内存溢出，那么可以通过减少最大堆和减少栈容量，来换取更多的线程。

<br>

### 方法区和运行时常量池溢出
&emsp;&emsp; 可以通过-XX:PermSize和-XX:MaxPermSize限制方法区的大小。间接限制常量池的容量。方法区溢出是一种常见的内存溢出异常，
一个类要被垃圾收集器回收掉，判断条件是很苛刻的。经常动态生成大量Class的应用容易产生OOM。String.intern()是一个native方法：
如果字符串常量池已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象，否则，将此String对象包含的字符串添加到常量池中，
并返回代表池中这个字符串的String对象。

<br>

### 本机直接内存溢出
&emsp;&emsp; 直接内存可以通过-XX:MaxDirectMemorySize指定，不指定默认与Java堆最大值一样。DirectByteBuffer分配内存抛内存溢出异常时，
并没有真正申请分配内存，而是先计算无法分配，于是手动抛出了异常，真正分配内存的方法是unsafe.allocateMemory()。由于直接内存导致的内存溢出，
特征是Heap Dump文件不会有明显的异常，OOM之后Dump文件很小，而且程序直接或间接使用了NIO，那么可能就是这方面原因。

<h2 id = "5">5.垃圾回收</h2>
&emsp;&emsp; 程序计数器、虚拟机栈、本地方法栈，生命周期同线程生命周期，这些区域的内存分配和回收具备确定性。Java堆和方法区不一样，
一个接口的多个实现类需要的内存不一样，一个方法中多个分支需要的内存也不一样，只有程序运行期才知道会创建哪些对象，这部分内存回收是动态的。
这部分也是垃圾收集器所关注的部分。

<br>

### 对象存活状态判断
#### 1.引用计数算法
&emsp;&emsp; 给对象添加一个引用计数器，有地方引用时计数器加一，引用失效，计数器减一，计数器为0的对象不可能再被使用。这种方法实现简单，判断效率高，
但是无法解决对象相互引用的问题。比如对象A、B互相引用，但这两个对象已无法被访问，但相互引用导致GC无法对它们进行回收。

<br>

#### 2.可达性分析算法
&emsp;&emsp; 将GC Roots作为起始点，从节点向下搜索，搜索走过的路称为引用链，当一个对象到GC Roots没有任何引用链相连，则证明对象是不可用的。
可作为GC Roots的对象包含：虚拟机栈(栈帧中的局部变量表)中引用的对象；方法区中类静态属性引用的对象；方法区中常量引用的对象；
本地方法栈中JNI(Native方法)引用的对象。

<br>
&emsp;&emsp; 引用计数法和可达性分析算法，都是引用有关。Java中引用定义：如果reference类型数据中存储的数值代表另一块内存的起始地址，
就称为这块内存代表着一个引用。这种定义使得对象只有被引用或没有被引用两种状态。所以对引用进行了扩充，根据引用强度将引用分为：强引用、软引用、弱引用、虚引用。

<br>
&emsp;&emsp; 强引用类似Object obj = new Object()，这类引用只要强引用存在，垃圾收集器就永远不会被回收掉。软引用描述有用但非必须对象，对于软引用关联的对象，
在系统将要发生内存溢出异常之前，会将这些对象列入回收范围中进行二次回收，如果回收还没有足够内存，那么将抛出内存溢出异常，使用SoftReference实现。
弱引用描述非必需对象，被弱引用关联的对象，只能生存到下一次垃圾收集发生之前。GC工作时，无论内存是否足够，都会回收掉只被弱引用关联的对象。
使用WeakReference实现。虚引用是最弱的引用关系，一个对象是否有虚引用不会对其生存时间构成影响，也无法通过虚引用获得一个对象实例。
为一个对象设置虚引用关联的唯一目的是能在这个对象被收集器回收时收到一个系统通知。使用PhantomReference实现。

<br>
&emsp;&emsp; 软引用可以实现内存敏感的高速缓存，软引用可以和一个引用队列(ReferenceQueue)联合使用，如果软引用所引用的对象被垃圾回收，
Java虚拟机就会把这个软引用加入到与之关联的引用队列中。弱引用类似软引用，只是生命周期更短，可以与引用队列一起使用。虚引用必须和引用队列一起使用，
GC回收对象时，发现该对象还有虚引用，那么会在回收之前把虚引用加入到与之关联的引用队列。程序可以通过引用队列是否加入了虚引用，了解被引用的对象是否要被回收，
就可以在引用对象内存被回收前采取必要的行动。

<br>

### 对象回收过程
&emsp;&emsp; 对于不可达对象，在消亡前至少要经历两次标记过程。如果对象与GC Roots没有引用关系，那么会第一次标记并筛选，筛选该对象是否有必要执行finalize方法，
如果对象没覆盖finalize()方法，或者finalize()已被调用过，那么视为没必要执行。如果有必要执行finalize()方法，那么对象会放置在F-Queue队列中，
并稍后由虚拟机自动建立的、低优先级的Finalizer线程执行。虚拟机会触发finalize()方法，但并不等待运行结束，因为如果等待，且finalize执行缓慢或循环，
那么其他对象将永久等待，导致内存回收系统崩溃。finalize后GC对F-Queue中对象进行二次标记，在finalize中如果重新构建了引用链，那么在第二次标记时，
将被移除出即将回收集合。如果对象这时还没逃脱，那么将被回收。具有不确定性，不保证对象调用顺序，不建议使用finalize()方法。

<br>

### 方法区回收
&emsp;&emsp; 方法区主要回收废弃常量和无用类，如果常量池中一个常量没有地方进行引用，这时发生内存回收，必要的话就会被清理出常量池。
判断一个类是否为无用类，必须满足3个条件：1.该类所有实例被回收，Java堆中不存在该类的任何实例。2.加载该类的ClassLoader被回收。
3.该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问。通过-Xnoclassgc控制是否对类进行回收，可以使用-verbose:class以及
-XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类加载卸载信息。在频繁使用反射、动态代理、CGLib等这类频繁自定义ClassLoader的
场景都需要虚拟机具备类卸载的功能，以避免内存溢出。

<br>

### 垃圾收集算法
#### 标记-清除算法
&emsp;&emsp; 该算法分两阶段：首先标记出所有要回收的对象，标记完成后统一回收所有被标记的对象。不足在于：1.效率不高，标记和清除两个过程效率都不高。
2.标记清除后会产生大量不连续的内存碎片，碎片太多会导致分配较大对象时，无法找到足够的连续内存而不得不再触发一次垃圾收集动作。

<br>

#### 复制算法
&emsp;&emsp; 将内存按容量划分为大小相等的两块，每次使用其中一块。一块使用完毕，将还存活的复制到另一块，再把用过的那块内存空间一次清理掉。
实现简单，运行高效，只是牺牲了一半的内存空间。研究表明新生代中98%对象都是朝生夕死，因此将内存划分为一块较大的Eden空间和两块较小的Survivor空间，
Eden : Survivor = 8 : 1。每次使用Eden和其中一块Survivor，因此每次新生代中可用内存空间为整个新生代容量的90%。当Survivor不够用时，
需要依赖老年代进行分配担保。如果Survivor没有足够空间存放上一次新生代收集下来的存活对象，这些对象将直接通过分配担保机制进入老年代。

<br>

#### 标记-整理算法
&emsp;&emsp; 存活率高时，复制算法要进行较多复制操作，效率变低。标记-整理法与标记-清除法类似，只是不是直接清理可回收对象，而是让所有存活对象往一端移动，
然后清理掉端边界以外的内存。

<br>

#### 分代收集算法
&emsp;&emsp; 当前商业虚拟机采用分代收集算法，根据对象存活周期的不同，将内存分为几块。一般分为新生代和老年代。新生代每次收集有大量对象消亡，
少量存活，就选用复制算法，老年代存活率高，没有额外空间进行分配担保，需要采用标记-清理或标记-整理进行回收。

<br>

### Hotspot 枚举根节点
&emsp;&emsp; 可达性分析从GC Roots节点开始找引用链，很多应用仅方法区就几百兆，逐个检查引用会消耗很多时间。GC时需要停顿所有Java执行线程(Stop The World)。
虚拟机通过OopMap数据结构直接知道哪些地方存放着对象引用。在类加载完成的时候，Hotspot就把对象内什么偏移量上是什么类型数据计算出来。
在OopMap协助下，Hotspot可以快速准确完成GC Roots枚举。

<br>

### 安全点
&emsp;&emsp; Hotspot不会为每条指令都生成OopMap，只在安全点产生。程序只要在到达安全点时才暂停。Safepoint不能太少，以至于GC等待时间太长，
也不能过于频繁。有两种方案可以在GC时让所有线程(除执行JNI调用的线程)都跑到最近的安全点停顿：抢先式中断和主动式中断。抢先式中断是GC时先中断所有线程，
如果发现中断的地方不在安全点，就恢复线程，让它跑到安全点。主动式中断是当GC需要中断线程时，设置一个标志，各个线程轮询标志，发现中断标志为真时自己中断挂起。
轮询标志的地方和安全点是重合的。

<br>
&emsp;&emsp; JVM会在内存分配的地方(即new一个新对象的时候)和长时间执行区块结束的时刻放置安全点，安全点一般会在如下几个位置点：
1、循环的末尾(无界循环)；2.方法临返回前；3.调用方法后；4.抛异常的位置。对于for (int i = 0; i < xxx; i++) 这种可以设置计数器的有限次数循环，
叫有界循环。对于for(;;) if condition return; 这种不知道要循环多少次，通过条件完成循环的叫无界循环，也可以用while实现无界循环。

<br>

### 安全区域
&emsp;&emsp; 当线程不执行即没有分配cpu时间时，如sleep或blocked时，无法相应JVM中断请求到达安全点，这时候需要安全区域(Safe Region)解决。
安全区域指在一段代码片段中，引用关系不会发生变化，在这个区域任意地方开始GC都是安全的。线程到达Safe Region时标记自己，当这段时间要发起GC时，
不用管标记为Safe Region状态的线程，线程离开Safe Region时，要检查是否完成了根节点枚举或整个GC过程，如果完成继续执行，
否则必须等待收到可以离开Safe Region的信号为止。在线程睡眠阻塞时，我们可以认为线程已经到达了safe region。在执行native方法时，
由于执行的是JVM管理外的代码，不会修改JVM状态，因此此时可看作已进入safe point 或 safe region。

<br>

### 垃圾收集器
#### Serial收集器
&emsp;&emsp; Serial收集器是单线程收集器，是单线程收集器，进行垃圾收集时必须暂停所有其他所有工作线程，直到收集结束。Serial收集器对于运行在
Client模式下的虚拟机是一个很好的选择。相比其他单线程收集器，简单高效。

<br>

#### ParNew收集器
&emsp;&emsp; 是Serial的多线程版本，Serial是许多运行在Server模式下的虚拟机首选的新生代收集器，使用复制算法。
只有Serial和ParNew能和CMS一起使用。CMS是老年代收集器。

<br>

#### Parallel Scavenge收集器
&emsp;&emsp; Parallel Scavenge是一个新生代收集器，使用复制算法。也是并行的多线程收集器。Parallel Scavenge收集器目的是达到一个可控的吞吐量，
吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)。Parallel Scavenge可以使用自适应调节策略。

<br>

#### Serial Old收集器
&emsp;&emsp; Serial Old是Serial收集器的老年代版本，使用标记-整理算法。主要两种用户：JDK1.5前与Parallel Scavenge收集器搭配使用；
作为CMS后备预案，在并发收集器发生Concurrent Mode Failure时使用。

<br>

#### Parallel Old收集器
&emsp;&emsp; Parallel Old是Parallel Scavenge收集器的老年代版本。使用标记-整理算法。

<br>

#### CMS收集器
&emsp;&emsp; CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。CMS使用标记-清除算法，整个过程分四步：
1.初始标记。2.并发标记。3.重新标记。4.并发清除。初始标记、重新标记需要Stop The World。初始标记只是标记GC Roots能直接关联到的对象，速度很快。
并发标记进行GC Roots Tracing。重新标记为了修正并发标记期间因用户程序继续运作导致标记产生变动的那一部分对象的标记记录，
这个阶段停顿时间比初始标记阶段长，但比并发标记时间短。并发标记和并发清除能与用户线程一起并发执行。

<br>
&emsp;&emsp; CMS优点在于：并发收集、低停顿，缺点在于：CMS对CPU资源敏感，CMS默认回收线程数为: (CPU数 + 3) / 4。在CPU数在4个以上时，
垃圾收集线程不少于25%的CPU资源，在CPU不足4个时，占用CPU资源占比更多。因此虚拟机提供了被称为"增量式并发收集器"的CMS收集器变种，
在并发标记、清理时，让GC线程、用户线程交替执行，这样垃圾收集时间会更长，但对用户程序影响会小一些。增量式CMS效果一般，已经deprecated。

<br>
&emsp;&emsp; 由于CMS并发标记、清理是与用户线程并发执行的，因此在标记后还会产生垃圾，这部分垃圾叫"浮动垃圾"，因此CMS需要给并发的用户线程预留内存，
CMS不能等到老年代几乎被填满再进行GC，使用-XX:CMSInitiatingOccupancyFraction来确定触发GC时的使用率，如果CMS运行时内存不足，
会出现Concurrent Mode Failure失败，这时使用后备预案，临时使用Serial Old来进行老年代的GC，只是这样停顿时间会变长。

<br>
&emsp;&emsp; CMS基于标记-清除，因此会产生空间碎片，空间碎片过多时会出现老年代有大量剩余空间，但是无法找到足够的内存分配当前对象。这样会触发一次Full GC。
CMS提供了-XX:CMSCompactAtFullCollection 默认开启，用于在CMS进行Full GC时开启内存碎片的合并整理过程。但内存整理无法并发，导致停顿时间变长。
虚拟机提供了-XX:CMSFullGCsBeforeCompaction，设置执行多少次不压缩的Full GC后，进行一次带压缩的Full GC。

<br>

#### G1收集器
&emsp;&emsp; G1(Garbage-First)特点：并行与并发；分代收集；空间整理；可预测的停顿。G1从整体看是基于标记-整理算法，从局部(两个Region)看，
基于复制算法，G1运行期间不会产生内存碎片。G1能建立可预测的停顿空间模型，能让使用者明确在长度为M毫秒的时间段内，消耗在GC上不超过N毫秒。
G1将Java堆划分为多个大小相等的独立区域(Region)。G1会优先收集价值最大的Region，这样保证在有限的时间内尽可能提高收集效率。G1收集过程分四步：
1.初始标记。2.并发标记。3.最终标记。4.筛选回收。

<br>

### 对象内存分配
&emsp;&emsp; 对象主要分配在新生代Eden区，如果启动了本地线程分配缓冲，那么优先分配在TLAB上。对象优先分配在新生代Eden区，Eden没有足够空间，
那么执行一次Minor GC。-XX:+PrintGCDetails在收集器发生GC时打印回收日志，并在进程退出时输出当前内存区域分配情况。

<br>
&emsp;&emsp; Minor GC 新生代GC，发生在新生代的垃圾收集，Minor GC发生很频繁，回收速度也很快。 Major GC/Full GC 老年代GC，发生在老年代的GC，
Major GC至少伴随一次Minor GC，Major GC速度比Minor GC慢10倍以上。

<br>

### 大对象直接进入老年代
&emsp;&emsp; 典型的大对象是很长的字符串以及数组。虚拟机提供了-XX:PretenureSizeThreshold，大于这个值的对象直接在老年代分配。
这样避免在Eden以及两个Survivor之间发生大量内存复制。

<br>

### 长期存活的对象进入老年代
&emsp;&emsp; 虚拟机给每个对象定义了对象年龄计数器。如果对象在Eden出生，经过一次Minor GC后仍存活，并且能被Survivor容纳，那么被移动到Survivor中，
年龄加1，当年龄增加到一定程度(默认为15)，会升到老年代。对于晋升老年代的年龄阀值可以通过-XX:MaxTenuringThreshold设置。

<br>

### 动态对象年龄判定
&emsp;&emsp; 如果Survivor空间中相同年龄对象大小总和占Survivor空间的一般，年龄大于或等于这个年龄的对象可以进入老年代。

<br>

### 空间分配担保
&emsp;&emsp; Minor GC前会检查老年代最大可用连续空间是否大于新生代所有对象总空间，如果成立，那么Minor GC确保是安全的。不成立的话，
虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许的话，那么会检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小，
如果大于会尝试进行一次Minor GC，如果小于或者HandlePromotionFailure不允许冒险，那么要改为进行一次Full GC。如果某次Minor GC存活后的对象突增，
高于平均值，那么会导致担保失败，如果出现HandlePromotionFailure失败，那么只好失败后重新发起一次Full GC。

<h2 id = "6">6.类文件结构</h2>
&emsp;&emsp; 任何一个Class文件都对应着唯一一个类或者接口的定义信息，Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序，
紧凑排列在Class文件中，中间没有添加任何分隔符，当遇到占用8位字节以上空间的数据项时，会按照高位在前的方式分割成若干个8位字节进行存储。
Class文件格式采用一种类似C语言结构体的伪结构存储数据，这种伪结构只有两种数据类型：无符号数和表。

<br>

### Class文件版本
&emsp;&emsp; Class文件头4个字节称为魔数(Magic Number)，用来确定这个文件是否为一个能被虚拟机接受的Class文件。第5和第6个字节是次版本号(Minor Version)，
第7第8个字节是主版本号(Major Version)。Class版本号能用来判断当前版本的虚拟机能否执行这个Class文件。

<br>

### 常量池
&emsp;&emsp; 紧接着主次版本号后是常量池入口。常量池是Class文件结构中与其他项目关联最多的数据类型，也是Class文件中第一个出现的表类型数据项目。
常量池中常量数量不固定，在常量池入口需要放置一项2字节的数据，用来代表常量池容量计数值，常量池计数是从1开始的。常量池中主要存放两大类常量：
字面量和符号引用。字面量接近Java语言层面的常量概念，如文本字符串、声明为final的常量值等，符号引用包含下面三类常量：类和接口的全限定名；
字段的名称和描述符；方法的名称和描述符。虚拟机在加载Class文件时进行动态连接，也就是说Class文件不会保存各个方法、字段的最终内存布局信息。

<br>
&emsp;&emsp; 常量池中每一项常量都是一个表。每个表第一位是一个u1(一字节无符号数)类型的标志位(tag)。

<br>

### 访问标志
&emsp;&emsp; 常量池结束后，紧跟的两个字节代表访问标志(access_flag)，用以识别类或接口层次的访问信息。包括：这个Class是类还是接口，
是否定义为public，是否为abstract，如果是类，是否声明为final等。

<br>

### 类索引、父类索引与接口索引集合
&emsp;&emsp; 类索引和父类索引都是u2(2字节无符号数)类型数据，接口索引集合是一组u2类型的数据集合。Class文件由这三项数据确定这个类的继承关系，
除了Object类，其他类都有父类，因此除了Object，所有Java类父类索引都不为0。接口索引集合用来描述这个类实现了哪些接口。

<br>
&emsp;&emsp; 类索引、父类索引、接口索引集合按顺序排列在访问标志之后。接口索引集合入口第一项是u2类型的数据作为接口计数器，表示索引表的容量。

<br>

### 字段表集合
&emsp;&emsp; 用于描述接口或者类中声明的变量。字段包括类级变量及实例级变量，不包含方法内部声明的局部变量。字段包含的信息包括：字段作用域(public等修饰符)、
实例变量还是类变量(static修饰符)、可变性(final)、并发可见性(volatile修饰符)、可否被序列化(transient修饰符)、字段数据类型(基本数据类型、对象、数组)、字段名称。
字段中修饰符都可以用标志位来表示，字段名称、字段被定义为什么类型是无法用标志符表示的，只能用常量池中常量表示。

<br>
&emsp;&emsp; 字段修饰符放在u2类型access_flags中，跟随access_flags的是两项索引值：name_index和descriptor_index它们都是对常量池的引用，
分别代表字段简单名称以及字段和方法的描述符。com/xiao/demo/TestDemo这种就是这个类的全限定名，仅仅把"."替换成了"/"，一般在最好后加上";"。
简单名称指没有类型和参数修饰的方法或字段名称，比如func()方法 m 字段简单名称分别为 func 和 m。方法和字段的描述符作用是描述字段的数据类型、
方法的参数列表(包括数量、类型、顺序)和返回值，基本数据类型以及代表无返回值的Void类型都用一个大写字符表示，对象类型用字符L加对象全限定名表示。
如B 表示byte，V表示Void，Ljava/lang/Obejct 表示 Object。数组类型使用前置"["，String[][]记录为"[[Ljava/lang/String"。

<br>
&emsp;&emsp; 用描述符描述方法时，按照先参数列表，后返回值的顺序描述，参数列表放在()中，如int indexOf(char[] source, int sourceOffset,
int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex)描述符为([CII[CIII)I

<br>

### 方法表集合
&emsp;&emsp; 方法表结构与字段表一样，包括访问标志(access_flags)、名称索引(name_index)、描述符索引(descriptor_index)、属性表集合(attributes)。
方法里面的代码经过编译成字节码指令后，存放在方法属性表集合中一个名为"Code"的属性里。方法表集合入口是u2类型的数量，表示计数器容量。

<br>

### 属性表集合
&emsp;&emsp; 在Class文件、字段表、方法表都可以携带自己的属性表集合。不要求各个属性表有严格顺序，只要不与已有的属性名重复，
任何人实现的编译器都可以写入自定义的属性信息，JVM运行时会忽略掉不认识的属性。

<br>

#### Code属性
&emsp;&emsp; Java代码经过 Javac编译器处理后，变为字节码存储在Code属性内，接口或抽象类中的方法不存在Code属性中。
字节码指令之后时这个方法的显式异常处理表集合，异常表对Code属性来说不是必须存在的。编译器使用异常表而不是简单的跳转命令来实现Java异常及finally处理机制。

<br>

### Exceptions属性
&emsp;&emsp; Exceptions属性是在方法表中与Code属性平级的一项属性，与异常表不同。作用是列出方法中可能抛出的受查异常。

<br>

### LineNumberTable
&emsp;&emsp; LineNumberTable描述Java源码行号与字节码行号之间的对应关系。默认生成到Class文件中，可取消生成。

<br>

### LocalVariableTable
&emsp;&emsp; 描述栈帧中局部变量表与Java源码中定义的变量之间的关系。不是运行时必要的属性，默认生成在Class文件中，可取消，如果没有生成这项属性，
最大影响是引用这个方法时，所有参数名称会丢失，会使用arg0、arg1之类的占位符替代原有参数名。

<br>

### SourceFile属性
&emsp;&emsp; 记录这个Class文件的源码文件名称，这个属性也可选。一般类的类名和文件名一致，但内部类不同。不生成这项属性，抛异常时，不会显式出错代码所属的文件名。

<br>

### ConstantValue属性
&emsp;&emsp; 作用是通知虚拟机自动为静态变量赋值，只有static修饰的变量才有这项属性。对于非static变量赋值是在实例构造器&lt;init&gt;方法中进行，
对于类变量，如果同时使用final和static修饰，并且这个变量的数据类型是基本类型或String，就生成ConstantValue属性进行初始化，
否则会在类构造器&lt;clinit&gt;方法中进行初始化。此属性的属性值只是一个常量池的索引号。

<br>

### InnerClasses属性
&emsp;&emsp; 用来记录内部类与宿主类之间的关联。

<br>

### Deprecated与Synthetic属性
&emsp;&emsp; 属于标志类型的布尔属性。Deprecated表示某个类、字段或方法是否被定为Deprecated。Synthetic由编译器添加，标志一个类、字段、方法是编译器自动产生的。

<br>

### StackMapTable属性
&emsp;&emsp; 位于Code属性的属性表中，这个属性在虚拟机加载的字节码验证阶段被新类型检查验证器使用。一个方法的Code属性最多只有一个StackMapTable属性，
否则抛出ClassFormatError异常。

<br>

### Signature属性
&emsp;&emsp; 任何类、接口、初始方法或成员的范型签名如果包含了类型变量或参数化类型，则Signature属性会为它记录泛型签名信息。
现在Java反射API能获取泛型数据，数据来源就是这个属性。

<br>

### BootstrapMethods属性
&emsp;&emsp; 这个属性保存invokedynamic指令引用的引导方法限定符。

<h2 id="7">7.字节码指令</h2>
&emsp;&emsp; JVM的指令由一个字节长度的、代表某种特定操作含义的数字(称为操作码)，以及跟随其后的零至多个代表此操作数所需参数(操作数)组成。
由于JVM采用面向操作数栈而不是寄存器的架构，所以大多数指令不包含操作数只有一个操作码。JVM的解释器可以用下面伪代码当作最基本的执行模型理解：

    <p>
        do {
            自动计算PC寄存器的值加1
            根据PC寄存器的指示位置，从字节码流中取出操作码
            if(字节码存在操作数) 从字节码流中取出操作数
            执行操作码所定义的操作
        } while(字节码流长度 > 0)
    </p>
    
<br>

### 字节码与数据类型
&emsp;&emsp; 大多数指令都包含了其操作所对应的数据类型信息。如iload用于从局部变量表中加载int类型的数据到操作数栈中。还有另外一些指令，
如无条件跳转goto则是与数据类型无关的。大多数对于boolean、byte、short、char类型数据的操作，都是使用相应的int类型作为运算类型。

<br>

### 加载和存储指令
&emsp;&emsp; 加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输。存储数据的操作数栈和局部变量表主要是由加载和存储指令进行操作，
除此外还有少量指令，如访问对象的字段或数组元素的指令也会像操作数栈传输数据。

<br>

### 运算指令
&emsp;&emsp; 运算或算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。算术指令分两类：整型数据进行运算的指令与对浮点型数据进行运算的指令。

<br>

### 类型转换指令
&emsp;&emsp; JVM直接支持小范围类型向大范围类型的安全转换。int到long、float、double，long到float、double，float到double。
这些宽化转换不需要显式的转换指令，窄化类型转换需要显式的转换指令。

<br>

### 方法调用和返回指令
&emsp;&emsp; invokevirtual用于调用对象的实例方法，根据对象的实际类型进行分派。invokeinterface用于调用接口方法，会在运行时搜索一个实现了这个接口方法的对象，
找出适合的方法进行调用。invokespecial用于调用需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。invokestatic用于调用类方法。
invokedynamic用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。前4条调用指令分派逻辑固化在JVM内部，invokedynamic指令分派逻辑由用户设定的引导方法决定的。

    <p>
       这里我写了一个Demo来获取各种方法调用涉及到的指令
       public class com.xiao.framework.base.jvm.InvokeDemo {
         public com.xiao.framework.base.jvm.InvokeDemo();
           Code:
              0: aload_0
              // 对象构造init()方法，使用invokespecial方法
              1: invokespecial #1                  // Method java/lang/Object."<init>":()V
              4: return
       
         public static void main(java.lang.String[]);
           Code:
              0: new           #2                  // class java/util/ArrayList
              3: dup
              4: invokespecial #3                  // Method java/util/ArrayList."<init>":()V
              7: astore_1
              8: aload_1
              9: ldc           #4                  // String Good Day
              // 这里通过接口调用，采用invokeinterface方法
             11: invokeinterface #5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z
             16: pop
             17: new           #2                  // class java/util/ArrayList
             20: dup
             21: invokespecial #3                  // Method java/util/ArrayList."<init>":()V
             24: astore_2
             25: aload_2
             26: ldc           #6                  // String Bad Day
             // 这里采用具体的对象调用，使用invokevirtual方法
             28: invokevirtual #7                  // Method java/util/ArrayList.add:(Ljava/lang/Object;)Z
             31: pop
             // 调用静态方法，使用invokestatic方法
             32: invokestatic  #8                  // Method print:()V
             // lambda 表达式采用invokedynamic方法
             35: invokedynamic #9,  0              // InvokeDynamic #0:run:()Lcom/xiao/framework/base/jvm/InvokeDemo$InvokeRunnable;
             40: astore_3
             41: aload_3
             42: invokeinterface #10,  1           // InterfaceMethod com/xiao/framework/base/jvm/InvokeDemo$InvokeRunnable.run:()V
             47: return
       }
    </p>


<br>

### 同步指令
&emsp;&emsp; JVM支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构使用管程(Monitor)支持的。JVM的指令集中有monitorenter和
monitorexit两条指令支持synchronized关键字。


<h2 id = "8">8.虚拟机类加载机制</h2>
&emsp;&emsp; Java的加载、连接、初始化都是在运行期间完成的，这种策略会增加类加载时的性能开销，但是会提供灵活性，可以先定义一个接口，
然后运行时指定实际的实现类。

<br>
&emsp;&emsp; 类从被加载到虚拟机内存中，到卸载出内存，整个生命周期包括7个阶段：加载(Loading)、验证(Verification)、准备(Preparation)、
解析(Resolution)、初始化(Initialization)、使用(Using)、卸载(Unloading)。其中验证(Verification)、准备(Preparation)、解析(Resolution)，
3个阶段统称为连接(Linking)。

<br>
&emsp;&emsp; 其中加载(Loading)、验证(Verification)、准备(Preparation)、初始化(Initialization)、卸载(Unloading)，
这5个阶段顺序是确定的，解析阶段不一定，某些情况下可以在初始化之后再进行，这是为了支持Java的运行时绑定。

<br>
&emsp;&emsp; 类加载的时机没有强制约束，由JVM自己自由把握，但初始化阶段，有且只有5种情况必须立即对类进行初始化：
1.遇到new、getstatic、publicstatic、invokestatic，如果类没有初始化，那么要先触发初始化。生成这4条指令的常见场景为：使用new实例化对象；
读取或设置一个类的静态字段（被final修饰，在编译期已经把结果放入常量池的静态字段除外）；调用一个类的静态方法。
2.使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
3.当初始化一个类的时候，其父类还没有进行过初始化，则需要先触发其父类的初始化。
4.虚拟机启动时，虚拟机会先初始化主类（包含main()的类）。这5种场景中的行为，称为对一个类进行主动引用，除此外是对类的被动引用，不会触发初始化。

<br>
&emsp;&emsp; 接口也是有初始化过程的，接口中不能使用static语句块，编译器还是会为接口生成&lt;clinit&gt()类构造器，
用于初始化接口中定义的成员变量，接口与类区别在于接口初始化时不要求其父类全部完成了初始化，只有真正用到父接口时，才会初始化;

<br>

### 加载阶段
&emsp;&emsp; 类加载的加载阶段完成以下3件事：1.通过一个类的全限定名来获取定义该类的二进制字节流。
2.将字节流所代表的静态存储结构转化为方法区的运行时数据结构。3.在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据入口。
对于数组类而言，数组类本身不通过类加载器创建，由JVM直接创建。数组类的元素类型最终靠类加载器创建数组类创建过程包括：1.如果数组组件类型是引用类型，
那么使用类加载过程加载这个组件类型，这个数组将在加载该组件类型的类加载器的类名称空间上被标识。2.如果数组类型不是引用类型，
那么JVM会把数组标记为与引导加载器关联。3.数组类的可见性与它的组件类型的可见性一致，如果不是引用类型，那么数组类可见性默认为public。


<br>

### 验证阶段
&emsp;&emsp; 验证是连接阶段的第一步，为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，不会危害虚拟机自身的安全。
会完成以下4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。
<br>
&emsp;&emsp; 文件格式验证是基于二进制字节流进行的，只有通过这个阶段的验证后，字节流才会进入内存的方法区中进行存储。后面的阶段都是基于方法区中的存储结构进行的，
不会再直接操作字节流。
<br>
&emsp;&emsp; 元数据验证，主要对类的元数据信息进行校验，确保不存在不符合Java语言规范的元数据信息。
<br>
&emsp;&emsp; 字节码验证，通过数据流和控制流分析，确保程序语义是合法的、符合逻辑的。将对类的方法体进行校验，保证不会作出危害虚拟机的事件。
<br>
&emsp;&emsp; 符号引用验证，判断引用的类、方法、字段等的引用合法性，发生在虚拟机将符号引用转化为直接引用时，在解析阶段发生。

<br>

### 准备阶段
&emsp;&emsp; 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。在Java8后，静态变量、常量是在java堆中存储。
例如：public static int value = 123; 这个类变量在准备阶段之后，值为0，而不是123。因为这时候尚未开始执行任何Java方法，
真正赋值是在程序被编译后，执行类构造器<clinit>()方法时完成赋值。赋值动作将会在初始化阶段才会执行。
如果类字段属性表中存在ConstantValue属性，那么准备阶段变量就会被初始化为ConstantValue属性指定的值。
如：public static final int value = 123; 此时准备阶段，会赋真值。

<br>

### 解析阶段
&emsp;&emsp; 解析阶段是将虚拟机常量池中的符号引用替换为直接引用的过程。符号引用以一组符号描述所引用的目标，符号引用可是是任何形式的字面量，
只要使用时能无歧义的定位到目标即可，引用的目标不一定已经加载到内存中。直接引用可以是指向目标的指针、相对偏移量或一个能间接定位到目标的句柄。
直接引用和虚拟机实现的内存布局相关，如果有了直接引用，那么引用的目标必定已经在内存中存在。 解析动作主要针对类或接口、字段、类方法、接口方法、
方法类型、方法句柄和调用点限定符7类符号引用进行。

<br>

#### 类或接口的解析
&emsp;&emsp; 在类D中，如果把一个未解析过的符号引用N解析为一个类或接口C的直接引用，那么需要经过3个步骤：1.如果不是数组类型，
那么虚拟机把代表N的全限定名传递给D的类加载器加载这个类C。如果加载异常，那么解析过程失败。2.如果C是数组，那么按照1的规则加载数组元素类型，
接着由虚拟机生成一个代表此数组维度和元素的数组对象。3.如果加载C成功，那么需要进行符号引用验证，确认D是否具备对C的访问权限，如果不具备，
抛出IllegalAccessError异常。

<br>

#### 字段解析
&emsp;&emsp; 字段解析时，首先对字段表所属的类或接口C的符号引用进行解析，如果解析成功，要进行以下步骤：1.如果C本身包含了这个字段，
那么返回这个字段的直接引用，查找结束。2.否则，如果C中实现了接口，那么从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标匹配的字段，
那么返回这个字段，查找结束。3.否则，如果C不是Object的话，那么按照继承关系从下到上递归搜索父类，如果父类中包含了简单名称和字段描述符都与目标匹配的字段，
那么返回这个字段的直接引用，查找结束。4.否则，抛出NoSuchFieldError异常。查找成功后，会对这个字段进行权限验证，如果不具备访问权限，
抛出IllegalAccessError异常。

<br>

#### 类方法解析
&emsp;&emsp; 类方法解析也是需要先解析出类方法表中索引的方法所属的类或接口C的符号引用，如果解析C成功，那么步骤如下：1.如果发现索引的C是个接口，
那么抛出IncompatibleClassChangeError异常。2.在类C中查找简单名称和描述符都与目标匹配的方法，如果有则返回方法的直接引用，查找结束。
3.否则，在类C的父类中递归查找简单名称和描述符与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。4.否则，在类C实现的接口及父类接口中，
递归查找匹配的方法，如果匹配，说明类C是个抽象类，这时查找结束，抛出AbstractMethodError异常。5.否则查找失败，抛出IllegalAccessError异常。

<br>

#### 接口方法解析
&emsp;&emsp; 先解析方法所属的类或接口C的符号引用，然后进行如下步骤：1. 如果发现索引的是个类而不是接口，抛出IncompatibleClassChangeError异常。
2.否则，在接口C中找出匹配的方法，如果有则返回这个方法的直接引用，查找结束。3.否则，在父接口中递归查找，直到Object类为止，如果有匹配的方法，
则返回这个方法的直接引用，查找结束。4.否则查找失败，抛出NoSuchMethodError异常。

<br>

### 初始化
&emsp;&emsp; 初始化是类加载的最后一步，初始化阶段是执行类构造器&lt;clinit&gt;()方法的过程。
&lt;clinit&gt;() 方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，顺序是由语句在源文件中出现的顺序决定的，
静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。
&lt;clinit&gt;() 方法与类的构造函数(&lt;clinit&gt;())不同，不需要显式的调用父类构造器，虚拟机会保证在子类&lt;clinit&gt;()方法执行前，
父类的&lt;clinit&gt;()方法已经执行完毕。

<br>
&emsp;&emsp; 如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器不会为这个类生成&lt;clinit&gt;()方法。接口中不能使用静态语句块，
但是仍有变量初始化的赋值操作，因此接口也有&lt;clinit&gt;()方法，只是不需要先执行父接口的&lt;clinit&gt;()方法。只有父接口使用时，父接口才会初始化。
接口的实现类初始化时也一样不会执行接口的&lt;clinit&gt;()方法。

<br>
&emsp;&emsp; 虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确加锁、同步。如果多个线程同时初始化一个类，
只会有一个线程执行这个类的&lt;clinit&gt;()方法，其他线程阻塞，直到活动线程&lt;clinit&gt;()执行完毕。

<br>

### 类加载器
&emsp;&emsp; 类加载器用于实现类的加载动作，通常类加载器分3种：启动类加载器(Bootstrap ClassLoader)：负责把&lt;JAVA_HOME&gt;\lib目录中的，
或者-Xbootclasspath参数指定路径中，并且是虚拟机识别的类库加载到虚拟机内存中。扩展类加载器(Extension ClassLoader)：负责加载&lt;JAVA_HOME&gt;\ext目录中，
或者被java.ext.dirs系统变量指定的路径中的类库。应用程序加载器(Application ClassLoader)：这个加载器是ClassLoader中getSystemClassLoader()方法的返回值，
因此称为系统类加载器。负责加载用户路径(classpath)上指定的类库。一般这个是程序中默认的类加载器。

<br>
&emsp;&emsp; 自定义类加载器 -> 应用程序加载器 -> 扩展类加载器 -> 启动类加载器 这种类加载器之间的关系称为类加载器的双亲委派模型。

<br>

### 双亲委派模式
&emsp;&emsp; 双亲委派模型工作过程是：如果一个类加载器收到了类加载的请求，那么它首先不会尝试加载这个类，而是先把这个请求委派给父类加载器去完成，
只有当父类加载器反馈无法完成这个加载请求时，子类加载器才会尝试自己去加载。

<h2 id="9">9.虚拟机字节码执行引擎</h2>
&emsp;&emsp; 在不同的虚拟机实现里面，执行引擎在执行代码的时候可能会有解释执行(通过解释器执行)和编译执行(通过即时编译器产生本地代码执行)两种。
JVM的执行引擎都是：输入字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。

<br>

### 运行时栈帧结构
&emsp;&emsp; 栈帧用于支持虚拟机进行方法调用和方法执行的数据结构。每一个栈帧都包含了局部变量表、操作数栈、动态连接、方法返回地址。
一个线程中方法调用链很长，很多方法同时处于执行状态，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，与这个栈帧关联的方法称为当前方法。

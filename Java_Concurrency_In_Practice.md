## Java Concurrency In Practice Notes

* [1.Introduction](#1)

<h2 id="1">1.Introduction</h2>
&emsp;&emsp; Java中主要同步机制是关键字synchromized，还包括volatile类型的变量，显式锁，原子变量。多个线程访问同一个可变的状态变量时，
没有使用合适的同步，那么程序会出错，三种方式可修复问题：1.不在线程之间共享状态变量。2.将状态变量修改为不可变的变量。3.在访问状态变量时使用同步。

<br>
&emsp;&emsp; 无状态的对象一定是线程安全的，例如：Servlet。实际中尽量使用线程安全对象来管理类的状态，如AtomicLong。
Java提供了一种内置的锁机制来支持原子性：同步代码块（Synchronized Block）。同步代码块分两部分：一个作为锁的对象的引用，一个作为由这个锁保护的代码块。
以关键字synchronized来修饰的方法是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的对象，静态synchronized方法以Class对象作为锁。

    <p>
    synchronized (lock) {
        // ops
    }
    </p>

<br>
&emsp;&emsp; 每个Java对象都可以用做一个实现同步的锁，这些锁被称为内置锁(Intrinsic Lock)或监视锁(Monitor Lock)。
线程在进入同步代码块之前会自动获得锁，并且无论正常退出还是抛异常退出同步代码块时，都会自动释放锁。获得内置锁唯一的方式就是进入这个锁保护的同步代码块或方法。
Java的内置锁是互斥锁，意味着最多只有一个线程能持有这种锁。

<br>
&emsp;&emsp; 内置锁是可重入的，如果一个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。获取锁的操作的粒度是线程而不是调用。
重入的一种实现方法是为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁就被认为是没有被任何线程持有，当线程请求一个没有被持有的锁时，
JVM记录下锁的持有者并将计数器置1，如果同一个线程再次获取这个锁，那么计数值递增，当线程退出同步代码块时，计数器会相应的递减，当计数器值为0时，
这个锁将被释放。

<br>
&emsp;&emsp; 对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。
对象的内置锁与其状态之间没有内在的关联，大多数类都将内置锁用做一种有效的加锁机制，但对象的域并不一定要通过内置锁保护，当获取与对象关联的锁时，
并不能阻止其他线程访问该对象，某个线程在获得对象的锁之后，只能阻止其他线程获得同一个锁。之所以每个对象都有一个内置锁，只是为了避免显式地创建锁对象。
每个共享可变的变量都应该只由一个锁来保护。

<br>
&emsp;&emsp; 一种常见的加锁约定是，将所有可变状态都封装在对象内部，通过对象内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问。
例如：Vector和其他同步集合类。如果在添加新的方法或代码路径时忘了使用同步，那么这种加锁协议很容易就被破坏。

<br>
&emsp;&emsp; 对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护。当执行时间较长的计算或者可能无法快速完成的操作时，
一定不要持有锁。当线程在没有同步的情况下读取变量时，可能得到一个失效值，这个值是由之前某个线程设置的值，而不是随机值，这种安全性保证被称为最低安全性。
最低安全性使用于绝大多数变量，但存在一个例外，非volatile类型的64位数值变量(double 和 long)。Java内存模型要求，变量的读和写操作都必须是原子操作。
但对于非volatile类型的long和double，JVM允许将64位的读或写操作，分解为两个32位的操作。在多线程中使用共享且可变的long和double，是不安全的，
除非用volatile声明或用锁保护起来。

<br>
&emsp;&emsp; 访问某个共享且可变的变量时要求所有线程在同一个锁上同步，用来保证某个线程写入该变量的值对于其他线程来说是可见的。

<br>
&emsp;&emsp; 当变量声明为volatile时，编译器与运行时不会将该变量上的操作与其他内存操作重排序。volatile变量不会被缓存在寄存器或其他处理器不可见的地方，
因此在读取colatile变量时总会返回最新写入的值。volatile变量是一种比synchronize关键字更轻量级的同步机制。不建议过度依赖volatile变量提供可见性，
在代码中过度依赖volatile控制状态的可见性，通常比锁更脆弱，也更难理解。volatile正确的使用方式包括：确保它们自身状态的可见性，
确保它们所引用对象的状态的可见性，以及标识一些重要的程序生命周期时间的发生。

<br>
&emsp;&emsp; 当且仅当满足以下条件时，才使用colatile变量：对变量的写入操作不依赖变量的当前值，或者能确保只有单个线程更新变量的值。
该变量不会与其他状态变量一起纳入不变性条件中。在访问变量时不需要加锁。

<br>
&emsp;&emsp; 发布(Publish) 一个对象，是指对象能够在当前作用域之外的代码中使用。发布对象最简单的方法是将对象的引用保存到一个公有的静态变量中，
以便任何类和线程都能看见该对象。

<br>
&emsp;&emsp; ThreadLocal能使线程中的某个值与保存值的对象关联起来。ThreadLocal提供了get set方法，这些方法为每个使用该变量的线程都留有一份独立的副本。
因此get总是返回由当前执行线程在调用set时设置的最新值。ThreadLocal 对象通常用于防止对可变的单实例变量或全局变量进行共享。
ThreadLocal用来维持线程封闭性。ThreadLocal变量类似于全局变量，能降低代码的可重用性，并在类之间引入隐含的耦合性，因此使用时要格外小心。

<br>
&emsp;&emsp; 不可变对象一定是线程安全的。不可变性不等于将对象的所有域声明为final，即使对象中所有域都是final类型的，对象仍然是可变的，
因为在final域中可以保存对可变对象的引用。满足以下条件时，对象才是不可变的：对象创建后状态不能修改，对象所有的域都是final，对象是正确创建的，
在对象创建期间，this引用没有逸出。如果final类型的域指向的是可变对象，那么在访问这些域所指向的对象的状态时，仍然需要使用同步。

<br>
&emsp;&emsp; 要安全的发布一个正确构造的对象，可以通过以下方式：在静态初始化函数中初始化一个对象引用；将对象的引用保存到volatile类型的域或AtomicReferance对象中；
将对象的引用保存到某个正确构造对象的final类型域中；将对象的引用保存到一个由锁保护的域中。

<br>
&emsp;&emsp; 线程安全库中的容器类提供了以下安全发布保证：1.通过将一个键或值放入HashTable、SynchronizedMap、或ConcurrentMap中，
可以安全的将它发布给任何从这些容器中访问它的线程。2.通过将某个元素放入Vector、CopyOnWriteArrayList、CopyOnWriteArraySet、SynchronizedList
或SynchronizedSet中，可以将该元素安全的发布到任何从这些容器中访问该元素的线程。3.通过将某个元素放入BlockingQueue或ConcurrentLinkedQueue中，
可以将该元素安全的发布到任何从这些队列中访问元素的线程。

<br>
&emsp;&emsp; 类库中其他数据传递机制（Future 和 Exchanger）同样能实现安全发布。通常发布一个静态构造的对象，最简单安全的方式是使用静态的初始化器，
静态初始化器由JVM在类的初始化阶段执行，由于JVM内部存在同步机制，因此通过这种方式初始化的任何对象都能被安全的发布。

    <p>
    public static Holder holder = new Holder(123);
    </p>
    
<br>
&emsp;&emsp; 如果对象从技术上来看是可变的，但其状态在发布后不会再改变，那么把这种对象称为事实不可变对象。
对象的发布需求取决于它的可变性：1.不可变对象可以通过任意机制来发布。2.事实不可变对象必须通过安全方式发布。3.可变对象必须通过安全方式发布，
并且必须是线程安全的或者由某个锁保护起来。

<br>
&emsp;&emsp; 在并发程序中使用和共享对象时，可以采用一些策略：1.线程封闭，线程封闭的类只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。
2.只读共享，在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程不能修改它，共享的只读对象包括不可变对象和事实不可变对象。
3.线程安全共享，线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。
4.保护对象，被保护的对象只能通过持有特定的锁来访问，保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定的锁保护的对象。